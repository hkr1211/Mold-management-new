# pages/maintenance_management.py - ä¿®å¤ç‰ˆæœ¬
import streamlit as st
import pandas as pd
import numpy as np
import logging
from datetime import datetime, timedelta, date
from utils.database import (
    execute_query, 
    get_db_connection,
    convert_numpy_types 
)

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Helper Functions ---

def safe_int(value, default=0):
    """å®‰å…¨åœ°è½¬æ¢å€¼ä¸ºæ•´æ•°ï¼Œå¤„ç†Noneå€¼"""
    if value is None:
        return default
    try:
        return int(value)
    except (ValueError, TypeError):
        return default

def safe_float(value, default=0.0):
    """å®‰å…¨åœ°è½¬æ¢å€¼ä¸ºæµ®ç‚¹æ•°ï¼Œå¤„ç†Noneå€¼"""
    if value is None:
        return default
    try:
        return float(value)
    except (ValueError, TypeError):
        return default

def get_maintenance_types():
    """è·å–ç»´ä¿®ä¿å…»ç±»å‹åˆ—è¡¨"""
    query = "SELECT type_id, type_name, is_repair, description FROM maintenance_types ORDER BY is_repair DESC, type_name"
    try:
        return execute_query(query, fetch_all=True)
    except Exception as e:
        st.error(f"è·å–ç»´ä¿®ä¿å…»ç±»å‹å¤±è´¥: {e}")
        return []

def get_maintenance_result_statuses():
    """è·å–ç»´ä¿®ä¿å…»ç»“æœçŠ¶æ€åˆ—è¡¨"""
    query = "SELECT status_id, status_name, description FROM maintenance_result_statuses ORDER BY status_name"
    try:
        return execute_query(query, fetch_all=True)
    except Exception as e:
        st.error(f"è·å–ç»´ä¿®ç»“æœçŠ¶æ€å¤±è´¥: {e}")
        return []

def get_molds_needing_maintenance():
    """è·å–éœ€è¦ç»´ä¿®ä¿å…»çš„æ¨¡å…·åˆ—è¡¨ - ä¿®å¤ç‰ˆæœ¬"""
    query = """
    SELECT 
        m.mold_id,
        m.mold_code,
        m.mold_name,
        COALESCE(mft.type_name, 'æœªçŸ¥ç±»å‹') as functional_type,
        COALESCE(ms.status_name, 'æœªçŸ¥çŠ¶æ€') as current_status,
        COALESCE(sl.location_name, 'æœªçŸ¥ä½ç½®') as current_location,
        COALESCE(m.theoretical_lifespan_strokes, 0) as theoretical_lifespan_strokes,
        COALESCE(m.accumulated_strokes, 0) as accumulated_strokes,
        COALESCE(m.maintenance_cycle_strokes, 0) as maintenance_cycle_strokes,
        CASE 
            WHEN COALESCE(m.maintenance_cycle_strokes, 0) > 0 AND COALESCE(m.accumulated_strokes, 0) > 0 THEN
                FLOOR(COALESCE(m.accumulated_strokes, 0)::FLOAT / COALESCE(m.maintenance_cycle_strokes, 1)) + 1
            ELSE 1
        END as next_maintenance_cycle,
        CASE 
            WHEN COALESCE(m.maintenance_cycle_strokes, 0) > 0 AND COALESCE(m.accumulated_strokes, 0) > 0 THEN
                ((FLOOR(COALESCE(m.accumulated_strokes, 0)::FLOAT / COALESCE(m.maintenance_cycle_strokes, 1)) + 1) * COALESCE(m.maintenance_cycle_strokes, 0)) - COALESCE(m.accumulated_strokes, 0)
            ELSE NULL
        END as strokes_to_next_maintenance,
        -- è·å–æœ€åä¸€æ¬¡ç»´ä¿®ä¿å…»æ—¶é—´
        (SELECT MAX(maintenance_start_timestamp) 
         FROM mold_maintenance_logs 
         WHERE mold_id = m.mold_id) as last_maintenance_date
    FROM molds m
    LEFT JOIN mold_functional_types mft ON m.mold_functional_type_id = mft.type_id
    LEFT JOIN mold_statuses ms ON m.current_status_id = ms.status_id
    LEFT JOIN storage_locations sl ON m.current_location_id = sl.location_id
    WHERE m.current_status_id IN (
        SELECT status_id FROM mold_statuses 
        WHERE status_name IN ('å¾…ç»´ä¿®', 'å¾…ä¿å…»', 'ç»´ä¿®ä¸­', 'ä¿å…»ä¸­', 'é—²ç½®')
    )
    ORDER BY 
        CASE 
            WHEN COALESCE(ms.status_name, '') IN ('å¾…ç»´ä¿®', 'å¾…ä¿å…»') THEN 1
            WHEN COALESCE(ms.status_name, '') IN ('ç»´ä¿®ä¸­', 'ä¿å…»ä¸­') THEN 2
            WHEN COALESCE(m.maintenance_cycle_strokes, 0) > 0 AND COALESCE(m.accumulated_strokes, 0) >= COALESCE(m.maintenance_cycle_strokes, 0) THEN 3
            ELSE 4
        END,
        m.mold_code
    """
    try:
        results = execute_query(query, fetch_all=True)
        
        # åå¤„ç†æ•°æ®ï¼Œç¡®ä¿æ‰€æœ‰æ•°å€¼éƒ½æ˜¯å®‰å…¨çš„
        processed_results = []
        for result in results:
            if isinstance(result, dict):
                processed_result = {}
                for key, value in result.items():
                    if key in ['theoretical_lifespan_strokes', 'accumulated_strokes', 'maintenance_cycle_strokes', 'next_maintenance_cycle']:
                        processed_result[key] = safe_int(value)
                    elif key == 'strokes_to_next_maintenance':
                        processed_result[key] = safe_int(value) if value is not None else None
                    else:
                        processed_result[key] = value
                processed_results.append(processed_result)
            else:
                processed_results.append(result)
        
        return processed_results
    except Exception as e:
        st.error(f"è·å–éœ€è¦ç»´ä¿®ä¿å…»çš„æ¨¡å…·å¤±è´¥: {e}")
        logging.error(f"Error in get_molds_needing_maintenance: {e}", exc_info=True)
        return []

def search_molds_for_maintenance(search_keyword=""):
    """æœç´¢æ¨¡å…·ç”¨äºç»´ä¿®ä¿å…»"""
    query = """
    SELECT 
        m.mold_id,
        m.mold_code,
        m.mold_name,
        COALESCE(mft.type_name, 'æœªçŸ¥ç±»å‹') as functional_type,
        COALESCE(ms.status_name, 'æœªçŸ¥çŠ¶æ€') as current_status,
        COALESCE(sl.location_name, 'æœªçŸ¥ä½ç½®') as current_location,
        COALESCE(m.theoretical_lifespan_strokes, 0) as theoretical_lifespan_strokes,
        COALESCE(m.accumulated_strokes, 0) as accumulated_strokes,
        COALESCE(m.maintenance_cycle_strokes, 0) as maintenance_cycle_strokes
    FROM molds m
    LEFT JOIN mold_functional_types mft ON m.mold_functional_type_id = mft.type_id
    LEFT JOIN mold_statuses ms ON m.current_status_id = ms.status_id
    LEFT JOIN storage_locations sl ON m.current_location_id = sl.location_id
    WHERE 1=1
    """
    
    params = []
    if search_keyword.strip():
        query += " AND (m.mold_code ILIKE %s OR m.mold_name ILIKE %s OR COALESCE(mft.type_name, '') ILIKE %s)"
        keyword_param = f"%{search_keyword.strip()}%"
        params.extend([keyword_param, keyword_param, keyword_param])
    
    query += " ORDER BY m.mold_code LIMIT 50"
    
    try:
        results = execute_query(query, params=tuple(params), fetch_all=True)
        
        # å®‰å…¨å¤„ç†ç»“æœ
        processed_results = []
        for result in results:
            if isinstance(result, dict):
                processed_result = {}
                for key, value in result.items():
                    if key in ['theoretical_lifespan_strokes', 'accumulated_strokes', 'maintenance_cycle_strokes']:
                        processed_result[key] = safe_int(value)
                    else:
                        processed_result[key] = value
                processed_results.append(processed_result)
            else:
                processed_results.append(result)
        
        return processed_results
    except Exception as e:
        st.error(f"æœç´¢æ¨¡å…·å¤±è´¥: {e}")
        return []

def get_mold_parts(mold_id):
    """è·å–æ¨¡å…·éƒ¨ä»¶åˆ—è¡¨"""
    query = """
    SELECT 
        mp.part_id,
        COALESCE(mp.part_code, '') as part_code,
        COALESCE(mp.part_name, 'æœªå‘½åéƒ¨ä»¶') as part_name,
        COALESCE(mpc.category_name, 'æœªåˆ†ç±»') as category_name,
        COALESCE(mp.material, '') as material,
        COALESCE(mp.lifespan_strokes, 0) as lifespan_strokes,
        COALESCE(ms.status_name, 'æœªçŸ¥çŠ¶æ€') as current_status
    FROM mold_parts mp
    LEFT JOIN mold_part_categories mpc ON mp.part_category_id = mpc.category_id
    LEFT JOIN mold_statuses ms ON mp.current_status_id = ms.status_id
    WHERE mp.mold_id = %s
    ORDER BY mpc.category_name, mp.part_name
    """
    try:
        return execute_query(query, params=(mold_id,), fetch_all=True)
    except Exception as e:
        st.error(f"è·å–æ¨¡å…·éƒ¨ä»¶å¤±è´¥: {e}")
        return []

# --- Main Functions ---

def show_maintenance_dashboard():
    """æ˜¾ç¤ºç»´ä¿®ä¿å…»ä»ªè¡¨æ¿ - ä¿®å¤ç‰ˆæœ¬"""
    st.subheader("ğŸ“Š ç»´ä¿®ä¿å…»æ¦‚è§ˆ")
    
    # è·å–ç»Ÿè®¡æ•°æ®
    try:
        # å¾…ç»´ä¿®ä¿å…»çš„æ¨¡å…·æ•°é‡
        pending_maintenance_query = """
        SELECT 
            COALESCE(ms.status_name, 'æœªçŸ¥çŠ¶æ€') as status_name,
            COUNT(*) as count
        FROM molds m
        LEFT JOIN mold_statuses ms ON m.current_status_id = ms.status_id
        WHERE COALESCE(ms.status_name, '') IN ('å¾…ç»´ä¿®', 'å¾…ä¿å…»', 'ç»´ä¿®ä¸­', 'ä¿å…»ä¸­')
        GROUP BY ms.status_name
        ORDER BY count DESC
        """
        pending_stats = execute_query(pending_maintenance_query, fetch_all=True)
        
        # è¿‘æœŸç»´ä¿®è®°å½•ç»Ÿè®¡
        recent_maintenance_query = """
        SELECT 
            COALESCE(mt.type_name, 'æœªçŸ¥ç±»å‹') as type_name,
            COUNT(*) as count,
            AVG(
                CASE 
                    WHEN mml.maintenance_end_timestamp IS NOT NULL AND mml.maintenance_start_timestamp IS NOT NULL THEN
                        EXTRACT(EPOCH FROM (mml.maintenance_end_timestamp - mml.maintenance_start_timestamp))/3600
                    ELSE NULL
                END
            ) as avg_hours
        FROM mold_maintenance_logs mml
        LEFT JOIN maintenance_types mt ON mml.maintenance_type_id = mt.type_id
        WHERE mml.maintenance_start_timestamp >= CURRENT_DATE - INTERVAL '30 days'
        GROUP BY mt.type_name
        ORDER BY count DESC
        """
        recent_stats = execute_query(recent_maintenance_query, fetch_all=True)
        
        # æ˜¾ç¤ºç»Ÿè®¡å¡ç‰‡
        col1, col2, col3, col4 = st.columns(4)
        
        # è®¡ç®—å„çŠ¶æ€æ•°é‡ï¼Œå®‰å…¨å¤„ç†
        pending_counts = {}
        if pending_stats:
            for stat in pending_stats:
                status_name = stat.get('status_name', 'æœªçŸ¥')
                count = safe_int(stat.get('count', 0))
                pending_counts[status_name] = count
        
        with col1:
            st.metric(
                "å¾…ç»´ä¿®", 
                pending_counts.get('å¾…ç»´ä¿®', 0),
                help="éœ€è¦ç«‹å³ç»´ä¿®çš„æ¨¡å…·æ•°é‡"
            )
        
        with col2:
            st.metric(
                "å¾…ä¿å…»", 
                pending_counts.get('å¾…ä¿å…»', 0),
                help="éœ€è¦ä¿å…»çš„æ¨¡å…·æ•°é‡"
            )
        
        with col3:
            st.metric(
                "ç»´ä¿®ä¸­", 
                pending_counts.get('ç»´ä¿®ä¸­', 0),
                help="æ­£åœ¨ç»´ä¿®çš„æ¨¡å…·æ•°é‡"
            )
        
        with col4:
            st.metric(
                "ä¿å…»ä¸­", 
                pending_counts.get('ä¿å…»ä¸­', 0),
                help="æ­£åœ¨ä¿å…»çš„æ¨¡å…·æ•°é‡"
            )
        
        # æ˜¾ç¤ºéœ€è¦å…³æ³¨çš„æ¨¡å…·
        st.markdown("---")
        st.subheader("âš ï¸ éœ€è¦å…³æ³¨çš„æ¨¡å…·")
        
        maintenance_needed = get_molds_needing_maintenance()
        if maintenance_needed:
            # æŒ‰ä¼˜å…ˆçº§åˆ†ç»„æ˜¾ç¤ºï¼Œå®‰å…¨å¤„ç†æ•°æ®
            urgent_molds = []
            in_progress_molds = []
            preventive_molds = []
            
            for m in maintenance_needed:
                current_status = m.get('current_status', '')
                maintenance_cycle = safe_int(m.get('maintenance_cycle_strokes', 0))
                strokes_to_next = m.get('strokes_to_next_maintenance')
                
                if current_status in ['å¾…ç»´ä¿®', 'å¾…ä¿å…»']:
                    urgent_molds.append(m)
                elif current_status in ['ç»´ä¿®ä¸­', 'ä¿å…»ä¸­']:
                    in_progress_molds.append(m)
                elif (current_status == 'é—²ç½®' and 
                      maintenance_cycle > 0 and 
                      strokes_to_next is not None and 
                      safe_int(strokes_to_next) <= 1000):
                    preventive_molds.append(m)
            
            if urgent_molds:
                st.markdown("#### ğŸš¨ ç´§æ€¥éœ€è¦å¤„ç†")
                for mold in urgent_molds[:5]:  # æ˜¾ç¤ºå‰5ä¸ª
                    with st.container():
                        col1, col2, col3 = st.columns([2, 1, 1])
                        with col1:
                            st.write(f"**{mold.get('mold_code', 'N/A')}** - {mold.get('mold_name', 'N/A')}")
                            st.write(f"çŠ¶æ€: {mold.get('current_status', 'N/A')} | ä½ç½®: {mold.get('current_location', 'N/A')}")
                        with col2:
                            theoretical = safe_int(mold.get('theoretical_lifespan_strokes', 0))
                            accumulated = safe_int(mold.get('accumulated_strokes', 0))
                            
                            if theoretical > 0:
                                usage_rate = (accumulated / theoretical) * 100
                                st.write(f"ä½¿ç”¨ç‡: {usage_rate:.1f}%")
                            else:
                                st.write("ä½¿ç”¨ç‡: N/A")
                        with col3:
                            if st.button(f"ğŸ”§ ç«‹å³å¤„ç†", key=f"urgent_{mold.get('mold_id')}", type="primary"):
                                st.session_state.maintenance_mold_id = mold.get('mold_id')
                                st.session_state.active_maintenance_tab = "create"
                                st.rerun()
            
            if preventive_molds:
                st.markdown("#### â° é¢„é˜²æ€§ä¿å…»æé†’")
                for mold in preventive_molds[:3]:  # æ˜¾ç¤ºå‰3ä¸ª
                    with st.container():
                        col1, col2, col3 = st.columns([2, 1, 1])
                        with col1:
                            st.write(f"**{mold.get('mold_code', 'N/A')}** - {mold.get('mold_name', 'N/A')}")
                        with col2:
                            remaining = safe_int(mold.get('strokes_to_next_maintenance', 0))
                            st.write(f"è·ç¦»ä¿å…»: {remaining:,} å†²æ¬¡")
                        with col3:
                            if st.button(f"ğŸ“… å®‰æ’ä¿å…»", key=f"preventive_{mold.get('mold_id')}"):
                                st.session_state.maintenance_mold_id = mold.get('mold_id')
                                st.session_state.active_maintenance_tab = "create"
                                st.rerun()
        else:
            st.info("âœ… å½“å‰æ²¡æœ‰éœ€è¦ç‰¹åˆ«å…³æ³¨çš„æ¨¡å…·")
        
        # è¿‘æœŸç»´ä¿®ç»Ÿè®¡å›¾è¡¨
        if recent_stats:
            st.markdown("---")
            st.subheader("ğŸ“ˆ è¿‘30å¤©ç»´ä¿®ä¿å…»ç»Ÿè®¡")
            
            # å®‰å…¨å¤„ç†ç»Ÿè®¡æ•°æ®
            chart_data = []
            for stat in recent_stats:
                type_name = stat.get('type_name', 'æœªçŸ¥ç±»å‹')
                count = safe_int(stat.get('count', 0))
                avg_hours = safe_float(stat.get('avg_hours'))
                
                chart_data.append({
                    'type_name': type_name,
                    'count': count,
                    'avg_hours': avg_hours if avg_hours > 0 else None
                })
            
            if chart_data:
                df_stats = pd.DataFrame(chart_data)
                
                col1, col2 = st.columns(2)
                with col1:
                    st.bar_chart(
                        df_stats.set_index('type_name')['count'],
                        height=300
                    )
                    st.caption("å„ç±»å‹ç»´ä¿®ä¿å…»æ¬¡æ•°")
                
                with col2:
                    # æ˜¾ç¤ºå¹³å‡è€—æ—¶
                    avg_hours_data = df_stats[df_stats['avg_hours'].notna()]
                    if not avg_hours_data.empty:
                        st.bar_chart(
                            avg_hours_data.set_index('type_name')['avg_hours'],
                            height=300
                        )
                        st.caption("å¹³å‡ç»´ä¿®ä¿å…»æ—¶é•¿ï¼ˆå°æ—¶ï¼‰")
                    else:
                        st.info("æš‚æ— æœ‰æ•ˆçš„æ—¶é•¿æ•°æ®")
        
    except Exception as e:
        st.error(f"åŠ è½½ç»´ä¿®ä¿å…»æ¦‚è§ˆå¤±è´¥: {e}")
        logging.error(f"Error in show_maintenance_dashboard: {e}", exc_info=True)

# ç»§ç»­åŒ…å«å…¶ä»–å‡½æ•°...
def create_maintenance_record():
    """åˆ›å»ºç»´ä¿®ä¿å…»è®°å½•"""
    st.subheader("ğŸ“ æ–°å»ºç»´ä¿®ä¿å…»è®°å½•")
    st.info("æ­¤åŠŸèƒ½å¼€å‘ä¸­ï¼Œè¯·ç¨åä½¿ç”¨...")

def view_maintenance_records():
    """æŸ¥çœ‹ç»´ä¿®ä¿å…»è®°å½•"""
    st.subheader("ğŸ“‹ ç»´ä¿®ä¿å…»è®°å½•")
    st.info("æ­¤åŠŸèƒ½å¼€å‘ä¸­ï¼Œè¯·ç¨åä½¿ç”¨...")

def show_maintenance_statistics():
    """æ˜¾ç¤ºç»´ä¿®ä¿å…»ç»Ÿè®¡åˆ†æ"""
    st.subheader("ğŸ“Š ç»´ä¿®ä¿å…»ç»Ÿè®¡åˆ†æ")
    st.info("æ­¤åŠŸèƒ½å¼€å‘ä¸­ï¼Œè¯·ç¨åä½¿ç”¨...")

# --- Main page function ---
def show():
    """Main function to show maintenance management page"""
    st.title("ğŸ”§ æ¨¡å…·ç»´ä¿®ä¿å…»ç®¡ç†")
    
    # Check user permissions
    user_role = st.session_state.get('user_role', '')
    if user_role not in ['è¶…çº§ç®¡ç†å‘˜', 'æ¨¡å…·åº“ç®¡ç†å‘˜', 'æ¨¡å…·å·¥']:
        st.warning("æ‚¨æ²¡æœ‰æƒé™è®¿é—®æ­¤åŠŸèƒ½")
        return
    
    # ä½¿ç”¨è¯´æ˜
    with st.expander("ğŸ’¡ ä½¿ç”¨è¯´æ˜", expanded=False):
        st.markdown("""
        ### ğŸ”§ ç»´ä¿®ä¿å…»ç®¡ç†åŠŸèƒ½è¯´æ˜
        
        **1. ç»´ä¿®ä¿å…»æ¦‚è§ˆ**
        - æŸ¥çœ‹å½“å‰éœ€è¦ç»´ä¿®ä¿å…»çš„æ¨¡å…·ç»Ÿè®¡
        - æ˜¾ç¤ºç´§æ€¥éœ€è¦å¤„ç†çš„æ¨¡å…·
        - æä¾›é¢„é˜²æ€§ä¿å…»æé†’
        
        **2. æ–°å»ºç»´ä¿®ä¿å…»è®°å½•**
        - æœç´¢é€‰æ‹©éœ€è¦ç»´ä¿®ä¿å…»çš„æ¨¡å…·
        - æ”¯æŒæ•´ä½“æ¨¡å…·æˆ–ç‰¹å®šéƒ¨ä»¶çš„ç»´ä¿®è®°å½•
        - è®°å½•è¯¦ç»†çš„ç»´ä¿®è¿‡ç¨‹å’Œç»“æœ
        
        **3. æŸ¥çœ‹ç»´ä¿®è®°å½•**
        - æŒ‰ç±»å‹ã€çŠ¶æ€ã€æ—¶é—´ç­‰æ¡ä»¶ç­›é€‰è®°å½•
        - æŸ¥çœ‹è¯¦ç»†çš„ç»´ä¿®ä¿å…»å†å²
        - è·Ÿè¸ªç»´ä¿®è¿›åº¦å’Œç»“æœ
        
        **4. ç»Ÿè®¡åˆ†æ**
        - åˆ†æç»´ä¿®ä¿å…»é¢‘ç‡å’Œæˆæœ¬
        - è¯†åˆ«é«˜ç»´ä¿®é¢‘ç‡çš„æ¨¡å…·
        - æŸ¥çœ‹ç»´ä¿®ä¿å…»è¶‹åŠ¿
        """)
    
    # æ ¹æ®ç”¨æˆ·è§’è‰²æ˜¾ç¤ºä¸åŒçš„æ ‡ç­¾é¡µ
    if user_role == 'æ¨¡å…·å·¥':
        # æ¨¡å…·å·¥ä¸»è¦å…³æ³¨ç»´ä¿®è®°å½•çš„åˆ›å»ºå’ŒæŸ¥çœ‹
        tab1, tab2, tab3 = st.tabs(["ğŸ“Š ç»´ä¿®æ¦‚è§ˆ", "ğŸ“ æ–°å»ºè®°å½•", "ğŸ“‹ æˆ‘çš„è®°å½•"])
        
        with tab1:
            show_maintenance_dashboard()
        
        with tab2:
            create_maintenance_record()
        
        with tab3:
            view_maintenance_records()
    else:
        # ç®¡ç†å‘˜å¯ä»¥çœ‹åˆ°å…¨éƒ¨åŠŸèƒ½
        tab1, tab2, tab3, tab4 = st.tabs(["ğŸ“Š ç»´ä¿®æ¦‚è§ˆ", "ğŸ“ æ–°å»ºè®°å½•", "ğŸ“‹ æŸ¥çœ‹è®°å½•", "ğŸ“ˆ ç»Ÿè®¡åˆ†æ"])
        
        with tab1:
            show_maintenance_dashboard()
        
        with tab2:
            create_maintenance_record()
        
        with tab3:
            view_maintenance_records()
        
        with tab4:
            show_maintenance_statistics()
    
    # æ£€æŸ¥æ˜¯å¦ä»å…¶ä»–é¡µé¢è·³è½¬åˆ°ç‰¹å®šæ ‡ç­¾
    active_tab = st.session_state.get('active_maintenance_tab')
    if active_tab == "create":
        st.session_state.active_maintenance_tab = None