# pages/loan_management.py
import streamlit as st
import pandas as pd
import numpy as np
import logging
from datetime import datetime, timedelta, date
from utils.database import (
    execute_query, 
    get_db_connection,
    get_loan_statuses, 
    convert_numpy_types 
)

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Helper Functions ---
def get_status_id_by_name(status_name, table_name="loan_statuses", name_column="status_name", id_column="status_id"):
    """Fetches the ID of a status by its name from a given status table."""
    query = f"SELECT {id_column} FROM {table_name} WHERE {name_column} = %s"
    try:
        result = execute_query(query, params=(status_name,), fetch_all=True)
        if result and len(result) > 0:
            return result[0][id_column]
        else:
            logging.error(f"Status '{status_name}' not found in table '{table_name}'.")
            st.error(f"ç³»ç»Ÿé”™è¯¯ï¼šæ— æ³•æ‰¾åˆ°çŠ¶æ€ '{status_name}'ã€‚è¯·è”ç³»ç®¡ç†å‘˜ã€‚")
            return None
    except Exception as e:
        logging.error(f"Error fetching status ID for '{status_name}' from '{table_name}': {e}")
        st.error(f"æ•°æ®åº“é”™è¯¯ï¼šèŽ·å–çŠ¶æ€IDå¤±è´¥ã€‚è¯¦æƒ…ï¼š{e}")
        return None

def get_available_molds_for_loan():
    """Fetches molds that are currently 'é—²ç½®' (Idle). Returns a DataFrame."""
    idle_status_id = get_status_id_by_name("é—²ç½®", table_name="mold_statuses")
    if not idle_status_id:
        logging.warning("Status 'é—²ç½®' not found, returning empty DataFrame for available molds.")
        return pd.DataFrame()

    query = """
    SELECT 
        m.mold_id,
        m.mold_code,
        m.mold_name,
        mft.type_name as functional_type,
        ms.status_name as current_status,
        sl.location_name as current_location
    FROM molds m
    LEFT JOIN mold_functional_types mft ON m.mold_functional_type_id = mft.type_id
    JOIN mold_statuses ms ON m.current_status_id = ms.status_id
    LEFT JOIN storage_locations sl ON m.current_location_id = sl.location_id
    WHERE m.current_status_id = %s
    ORDER BY m.mold_code
    """
    try:
        db_results = execute_query(query, params=(idle_status_id,), fetch_all=True)
        
        if isinstance(db_results, list):
            df = pd.DataFrame(db_results)
            return df
        elif db_results is None:
            logging.warning("execute_query returned None for available molds. Returning empty DataFrame.")
            return pd.DataFrame()
        else:
            logging.error(f"get_available_molds_for_loan: execute_query returned unexpected type {type(db_results)}. Value: {db_results}")
            st.error("èŽ·å–å¯ç”¨æ¨¡å…·åˆ—è¡¨æ—¶æ•°æ®æ ¼å¼é”™è¯¯ã€‚")
            return pd.DataFrame()

    except Exception as e:
        logging.error(f"Error in get_available_molds_for_loan: {e}", exc_info=True)
        st.error(f"åŠ è½½å¯ç”¨æ¨¡å…·åˆ—è¡¨æ—¶å‡ºé”™: {e}")
        return pd.DataFrame()

# --- Main Application Functions ---

def create_loan_application():
    """UI and logic for creating a new mold loan application."""
    st.subheader("ðŸ“ æ–°å»ºå€Ÿç”¨ç”³è¯·")

    current_user_id = st.session_state.get('user_id')
    if not current_user_id:
        st.warning("è¯·å…ˆç™»å½•ç³»ç»Ÿã€‚")
        return

    df_available_molds = get_available_molds_for_loan()
    
    if not isinstance(df_available_molds, pd.DataFrame):
        st.error("åŠ è½½å¯ç”¨æ¨¡å…·åˆ—è¡¨æ—¶å‘ç”Ÿå†…éƒ¨é”™è¯¯ï¼Œæ•°æ®ç±»åž‹ä¸æ­£ç¡®ã€‚")
        logging.error(f"create_loan_application expected DataFrame, got {type(df_available_molds)}")
        df_available_molds = pd.DataFrame(columns=['mold_id', 'mold_code', 'mold_name']) 

    if df_available_molds.empty:
        st.info("å½“å‰æ²¡æœ‰å¯ä¾›å€Ÿç”¨çš„é—²ç½®æ¨¡å…·ã€‚")
        return

    mold_options = {row['mold_id']: f"{row['mold_code']} - {row['mold_name']}" 
                    for index, row in df_available_molds.iterrows()}
    
    with st.form("loan_application_form"):
        selected_mold_id = st.selectbox("é€‰æ‹©æ¨¡å…·:", options=list(mold_options.keys()), format_func=lambda x: mold_options.get(x, "æœªçŸ¥æ¨¡å…·"))
        
        min_return_date = date.today() + timedelta(days=1)
        expected_return_date_input = st.date_input("é¢„è®¡å½’è¿˜æ—¥æœŸ:", min_value=min_return_date, value=min_return_date)
        
        destination_equipment_input = st.text_input("ä½¿ç”¨è®¾å¤‡/ç›®çš„åœ°:")
        remarks_input = st.text_area("å¤‡æ³¨:")
        
        submitted = st.form_submit_button("æäº¤ç”³è¯·")

    if submitted:
        if not selected_mold_id:
            st.error("è¯·é€‰æ‹©ä¸€ä¸ªæ¨¡å…·ã€‚")
            return
        if not destination_equipment_input.strip():
            st.error("è¯·å¡«å†™ä½¿ç”¨è®¾å¤‡/ç›®çš„åœ°ã€‚")
            return
        if not expected_return_date_input:
             st.error("è¯·é€‰æ‹©é¢„è®¡å½’è¿˜æ—¥æœŸã€‚")
             return

        try:
            with get_db_connection() as conn:
                conn.autocommit = False
                cursor = conn.cursor()

                # Get required status IDs
                pending_loan_status_id = get_status_id_by_name("å¾…å®¡æ‰¹", table_name="loan_statuses")

                if not pending_loan_status_id:
                    st.error("ç³»ç»Ÿé…ç½®é”™è¯¯ï¼šæ— æ³•èŽ·å–å¿…è¦çš„å€Ÿé˜…çŠ¶æ€IDã€‚è¯·è”ç³»ç®¡ç†å‘˜ã€‚")
                    conn.rollback()
                    return

                # Insert loan application using the correct table name
                insert_loan_query = """
                INSERT INTO mold_loan_records (
                    mold_id, applicant_id, application_timestamp, 
                    expected_return_timestamp, destination_equipment, remarks, loan_status_id
                ) VALUES (%s, %s, %s, %s, %s, %s, %s)
                """
                application_timestamp = datetime.now()
                cursor.execute(insert_loan_query, (
                    selected_mold_id, current_user_id, application_timestamp,
                    expected_return_date_input, destination_equipment_input, remarks_input, pending_loan_status_id
                ))

                conn.commit()
                st.success("å€Ÿç”¨ç”³è¯·å·²æˆåŠŸæäº¤ï¼ŒçŠ¶æ€ï¼šå¾…å®¡æ‰¹ã€‚")
                st.rerun()

        except Exception as e:
            logging.error(f"Loan application submission failed: {e}", exc_info=True)
            st.error(f"æäº¤ç”³è¯·å¤±è´¥ï¼š{e}")

def view_loan_applications():
    """UI and logic for viewing and managing loan applications."""
    st.subheader("ðŸ” æŸ¥çœ‹ä¸Žç®¡ç†å€Ÿç”¨ç”³è¯·")

    current_user_id = st.session_state.get('user_id')
    current_user_role = st.session_state.get('user_role')

    if not current_user_id:
        st.warning("è¯·å…ˆç™»å½•ã€‚")
        return

    # --- Filtering ---
    try:
        all_statuses = get_loan_statuses() or []
        status_filter_options = {0: "å…¨éƒ¨çŠ¶æ€"}
        status_filter_options.update({row['status_id']: row['status_name'] for row in all_statuses})
        
        selected_status_id = st.selectbox(
            "æŒ‰çŠ¶æ€ç­›é€‰:",
            options=list(status_filter_options.keys()),
            format_func=lambda x: status_filter_options[x],
            key="loan_status_filter"
        )
    except Exception as e:
        st.error(f"èŽ·å–çŠ¶æ€é€‰é¡¹å¤±è´¥: {e}")
        return

    # --- Fetching Data ---
    query_base = """
    SELECT
        mlr.loan_id, m.mold_code, m.mold_name,
        u_applicant.full_name AS applicant_name, mlr.application_timestamp,
        mlr.expected_return_timestamp, mlr.loan_out_timestamp, mlr.actual_return_timestamp,
        mlr.destination_equipment, ls.status_name AS loan_status, mlr.loan_status_id,
        u_approver.full_name AS approver_name, mlr.remarks,
        m.mold_id
    FROM mold_loan_records mlr
    JOIN molds m ON mlr.mold_id = m.mold_id
    JOIN users u_applicant ON mlr.applicant_id = u_applicant.user_id
    JOIN loan_statuses ls ON mlr.loan_status_id = ls.status_id
    LEFT JOIN users u_approver ON mlr.approver_id = u_approver.user_id
    """
    
    params = []
    if selected_status_id != 0:
        query_base += " WHERE mlr.loan_status_id = %s"
        params.append(selected_status_id)

    query_base += " ORDER BY mlr.application_timestamp DESC"
    
    try:
        loan_records = execute_query(query_base, params=tuple(params), fetch_all=True)
        
        if not loan_records:
            st.info("æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å€Ÿç”¨ç”³è¯·è®°å½•ã€‚")
            return
            
        loan_apps_df = pd.DataFrame(loan_records)
        
    except Exception as e:
        logging.error(f"Failed to load loan applications: {e}")
        st.error(f"åŠ è½½å€Ÿç”¨ç”³è¯·åˆ—è¡¨å¤±è´¥ï¼š{e}")
        return

    status_emoji = {
        "å¾…å®¡æ‰¹": "â³", "å·²æ‰¹å‡†": "âœ…", "å·²å€Ÿå‡º": "âž¡ï¸",
        "å·²å½’è¿˜": "ðŸ“¥", "å·²é©³å›ž": "âŒ", "é€¾æœŸ": "âš ï¸" 
    }

    for _, record_series in loan_apps_df.iterrows():
        record = convert_numpy_types(record_series.to_dict())
        loan_id = record['loan_id']
        mold_id = record['mold_id']

        emoji = status_emoji.get(record['loan_status'], "ðŸ“‹")
        expander_title = f"{emoji} {record['mold_code']} ({record['mold_name']}) - ç”³è¯·äºº: {record['applicant_name']} - çŠ¶æ€: {record['loan_status']}"
        
        with st.expander(expander_title):
            details_col, actions_col = st.columns([3, 1])

            with details_col:
                st.write(f"**ç”³è¯·IDï¼š** {loan_id}")
                st.write(f"**ç”³è¯·æ—¶é—´ï¼š** {record['application_timestamp'].strftime('%Y-%m-%d %H:%M') if pd.notna(record['application_timestamp']) else 'N/A'}")
                if pd.notna(record['expected_return_timestamp']):
                    st.write(f"**é¢„è®¡å½’è¿˜ï¼š** {record['expected_return_timestamp'].strftime('%Y-%m-%d')}")
                st.write(f"**ä½¿ç”¨è®¾å¤‡ï¼š** {record['destination_equipment']}")
                if pd.notna(record['loan_out_timestamp']):
                    st.write(f"**å€Ÿå‡ºæ—¶é—´ï¼š** {record['loan_out_timestamp'].strftime('%Y-%m-%d %H:%M')}")
                if pd.notna(record['actual_return_timestamp']):
                    st.write(f"**å½’è¿˜æ—¶é—´ï¼š** {record['actual_return_timestamp'].strftime('%Y-%m-%d %H:%M')}")
                if record['approver_name']:
                    st.write(f"**å®¡æ‰¹äººï¼š** {record['approver_name']}")
                if record['remarks']:
                    st.write(f"**ç”³è¯·å¤‡æ³¨ï¼š** {record['remarks']}")
            
            with actions_col:
                # Define permissions
                can_approve_reject = current_user_role in ['è¶…çº§ç®¡ç†å‘˜', 'æ¨¡å…·åº“ç®¡ç†å‘˜']
                can_manage_loan_flow = current_user_role in ['è¶…çº§ç®¡ç†å‘˜', 'æ¨¡å…·åº“ç®¡ç†å‘˜']

                if record['loan_status'] == 'å¾…å®¡æ‰¹' and can_approve_reject:
                    if st.button("âœ”ï¸ æ‰¹å‡†", key=f"approve_{loan_id}", help="æ‰¹å‡†æ­¤ç”³è¯·"):
                        if approve_loan_application(loan_id, mold_id, current_user_id):
                            st.rerun()
                    
                    rejection_reason = st.text_area("é©³å›žç†ç”±:", key=f"reject_reason_{loan_id}", height=100)
                    if st.button("âŒ é©³å›ž", key=f"reject_{loan_id}", help="é©³å›žæ­¤ç”³è¯·"):
                        if not rejection_reason.strip():
                            st.warning("è¯·è¾“å…¥é©³å›žç†ç”±ã€‚")
                        elif reject_loan_application(loan_id, mold_id, current_user_id, rejection_reason):
                            st.rerun()

                elif record['loan_status'] == 'å·²æ‰¹å‡†' and can_manage_loan_flow:
                    if st.button("âž¡ï¸ ç¡®è®¤å€Ÿå‡º", key=f"loan_out_{loan_id}", help="ç¡®è®¤æ¨¡å…·å·²å€Ÿå‡º"):
                        if mark_as_loaned_out(loan_id, mold_id, current_user_id):
                            st.rerun()
                
                elif record['loan_status'] == 'å·²å€Ÿå‡º' and can_manage_loan_flow:
                    if st.button("ðŸ“¥ æ ‡è®°å½’è¿˜", key=f"return_{loan_id}", help="æ ‡è®°æ¨¡å…·å·²å½’è¿˜"):
                        if mark_as_returned(loan_id, mold_id, current_user_id):
                            st.rerun()

def _update_loan_and_mold_status(loan_id, mold_id,
                                 current_loan_status_name, target_loan_status_name,
                                 current_mold_status_name, target_mold_status_name,
                                 operator_user_id, 
                                 loan_timestamp_field=None,
                                 loan_operator_field=None,
                                 remarks_field=None, remarks_value=None):
    """Generic function to update loan and mold statuses within a transaction."""
    try:
        with get_db_connection() as conn:
            conn.autocommit = False
            cursor = conn.cursor()

            # Get status IDs
            current_loan_status_id = get_status_id_by_name(current_loan_status_name, table_name="loan_statuses")
            target_loan_status_id = get_status_id_by_name(target_loan_status_name, table_name="loan_statuses")
            current_mold_status_id = get_status_id_by_name(current_mold_status_name, table_name="mold_statuses")
            target_mold_status_id = get_status_id_by_name(target_mold_status_name, table_name="mold_statuses")

            if not all([current_loan_status_id, target_loan_status_id, current_mold_status_id, target_mold_status_id]):
                st.error("ç³»ç»Ÿé…ç½®é”™è¯¯ï¼šæ— æ³•èŽ·å–æ“ä½œæ‰€éœ€çš„çŠ¶æ€IDã€‚")
                conn.rollback()
                return False

            # Verify current loan application status
            cursor.execute("SELECT loan_status_id, mold_id FROM mold_loan_records WHERE loan_id = %s", (loan_id,))
            app_data = cursor.fetchone()
            if not app_data or app_data[0] != current_loan_status_id or app_data[1] != mold_id:
                st.warning(f"æ“ä½œå¤±è´¥ï¼šç”³è¯·çŠ¶æ€ (åº”ä¸º {current_loan_status_name}) æˆ–æ¨¡å…·ä¸åŒ¹é…ã€‚è¯·åˆ·æ–°é¡µé¢ã€‚")
                conn.rollback()
                return False

            # Verify current mold status
            cursor.execute("SELECT current_status_id FROM molds WHERE mold_id = %s", (mold_id,))
            mold_data = cursor.fetchone()
            if not mold_data or mold_data[0] != current_mold_status_id:
                st.warning(f"æ“ä½œå¤±è´¥ï¼šæ¨¡å…·çŠ¶æ€ (åº”ä¸º {current_mold_status_name}) ä¸æ­£ç¡®ã€‚è¯·åˆ·æ–°é¡µé¢ã€‚")
                conn.rollback()
                return False
                
            # Update loan application
            update_loan_q = "UPDATE mold_loan_records SET loan_status_id = %s"
            params_loan = [target_loan_status_id]
            
            now_timestamp = datetime.now()
            if loan_timestamp_field:
                update_loan_q += f", {loan_timestamp_field} = %s"
                params_loan.append(now_timestamp)
            if loan_operator_field:
                update_loan_q += f", {loan_operator_field} = %s"
                params_loan.append(operator_user_id)
            if remarks_field and remarks_value is not None:
                update_loan_q += f", {remarks_field} = %s"
                params_loan.append(remarks_value)
            
            update_loan_q += " WHERE loan_id = %s AND loan_status_id = %s"
            params_loan.extend([loan_id, current_loan_status_id])
            
            cursor.execute(update_loan_q, tuple(params_loan))
            if cursor.rowcount == 0:
                st.warning("æ“ä½œå¤±è´¥ï¼šç”³è¯·è®°å½•æ›´æ–°å¤±è´¥ï¼Œå¯èƒ½å·²è¢«å¹¶å‘ä¿®æ”¹ã€‚")
                conn.rollback()
                return False

            # Update mold status
            update_mold_q = """
                UPDATE molds SET current_status_id = %s, updated_at = %s
                WHERE mold_id = %s AND current_status_id = %s
            """
            cursor.execute(update_mold_q, (target_mold_status_id, now_timestamp, mold_id, current_mold_status_id))
            if cursor.rowcount == 0:
                st.error("ä¸¥é‡é”™è¯¯ï¼šæ¨¡å…·çŠ¶æ€æ›´æ–°å¤±è´¥ï¼Œä½†ç”³è¯·å·²æ›´æ–°ï¼è¯·è”ç³»ç®¡ç†å‘˜æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§ã€‚")
                conn.rollback()
                return False

            conn.commit()
            st.success(f"æ“ä½œæˆåŠŸï¼šç”³è¯· {loan_id} çŠ¶æ€å·²æ›´æ–°ä¸º {target_loan_status_name}ã€‚")
            return True

    except Exception as e:
        logging.error(f"Error during status update for loan {loan_id}: {e}", exc_info=True)
        st.error(f"æ“ä½œå¤±è´¥ï¼š{e}")
        return False

def approve_loan_application(loan_id, mold_id, approver_user_id, approval_remarks=""):
    return _update_loan_and_mold_status(
        loan_id, mold_id,
        current_loan_status_name="å¾…å®¡æ‰¹", target_loan_status_name="å·²æ‰¹å‡†",
        current_mold_status_name="é—²ç½®", target_mold_status_name="å·²å€Ÿå‡º",
        operator_user_id=approver_user_id,
        loan_timestamp_field="approval_timestamp",
        loan_operator_field="approver_id"
    )

def reject_loan_application(loan_id, mold_id, approver_user_id, rejection_remarks):
    if not rejection_remarks or not rejection_remarks.strip():
        st.error("é©³å›žæ“ä½œå¿…é¡»å¡«å†™é©³å›žç†ç”±ã€‚")
        return False
    return _update_loan_and_mold_status(
        loan_id, mold_id,
        current_loan_status_name="å¾…å®¡æ‰¹", target_loan_status_name="å·²é©³å›ž",
        current_mold_status_name="é—²ç½®", target_mold_status_name="é—²ç½®",
        operator_user_id=approver_user_id,
        loan_timestamp_field="approval_timestamp",
        loan_operator_field="approver_id",
        remarks_field="remarks", remarks_value=rejection_remarks
    )

def mark_as_loaned_out(loan_id, mold_id, operator_user_id):
    return _update_loan_and_mold_status(
        loan_id, mold_id,
        current_loan_status_name="å·²æ‰¹å‡†", target_loan_status_name="å·²å€Ÿå‡º",
        current_mold_status_name="å·²å€Ÿå‡º", target_mold_status_name="å·²å€Ÿå‡º",
        operator_user_id=operator_user_id,
        loan_timestamp_field="loan_out_timestamp"
    )

def mark_as_returned(loan_id, mold_id, operator_user_id, return_remarks=""):
    return _update_loan_and_mold_status(
        loan_id, mold_id,
        current_loan_status_name="å·²å€Ÿå‡º", target_loan_status_name="å·²å½’è¿˜",
        current_mold_status_name="å·²å€Ÿå‡º", target_mold_status_name="é—²ç½®",
        operator_user_id=operator_user_id,
        loan_timestamp_field="actual_return_timestamp"
    )

# --- Main page function ---
def show():
    """Main function to show loan management page"""
    st.title("ðŸ› ï¸ æ¨¡å…·å€Ÿç”¨ç®¡ç†")
    
    # Check user permissions
    user_role = st.session_state.get('user_role', '')
    if user_role not in ['è¶…çº§ç®¡ç†å‘˜', 'æ¨¡å…·åº“ç®¡ç†å‘˜', 'å†²åŽ‹æ“ä½œå·¥']:
        st.warning("æ‚¨æ²¡æœ‰æƒé™è®¿é—®æ­¤åŠŸèƒ½")
        return
    
    # Page selection
    if user_role == 'å†²åŽ‹æ“ä½œå·¥':
        # Operators can only create applications and view their own
        page_options = {
            "æ–°å»ºå€Ÿç”¨ç”³è¯·": create_loan_application,
            "æŸ¥çœ‹æˆ‘çš„ç”³è¯·": view_loan_applications
        }
    else:
        # Admins can manage all applications
        page_options = {
            "æŸ¥çœ‹ä¸Žç®¡ç†ç”³è¯·": view_loan_applications,
            "æ–°å»ºå€Ÿç”¨ç”³è¯·": create_loan_application
        }
    
    # Use tabs for page navigation
    if len(page_options) > 1:
        tabs = st.tabs(list(page_options.keys()))
        for i, (page_name, page_func) in enumerate(page_options.items()):
            with tabs[i]:
                page_func()
    else:
        # Single page
        list(page_options.values())[0]()